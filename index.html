<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Drift Rush - Christmas Special</title>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap');
        
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        
        /* WEIHNACHTS-FARBSCHEMA: Rot (#d42426) und Gr√ºn (#165b33) statt Gelb/Blau */
        #start-screen, #game-menu, #hud, #controls-hud, #settings-menu {
            position: absolute; font-family: 'Orbitron', sans-serif; 
            color: #d42426; /* Weihnachtsrot */
            z-index: 10;
        }

        /* --- MEN√ú STILE (START/MENU/SETTINGS) --- */
        #start-screen {
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.95); display: flex;
            flex-direction: column; justify-content: center;
            align-items: center; text-align: center;
            transition: opacity 1s, visibility 1s;
        }
        /* Text mit "Schnee"-Effekt (wei√üer Glow) */
        #start-screen h1 { font-size: 8em; margin-bottom: 5px; letter-spacing: 10px; text-shadow: 0 0 20px #d42426, 0 0 40px #fff; color: #fff; }
        #start-screen p { font-family: 'Roboto', sans-serif; color: #ccc; font-size: 1.5em; font-weight: 300; }
        .start-button {
            background-color: #d42426; color: #fff; border: none; /* Roter Button */
            padding: 25px 60px; margin: 40px 0 20px 0; font-size: 2.5em;
            font-weight: 700; border-radius: 12px; cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 0 15px rgba(212, 36, 38, 0.6);
            border: 2px solid #fff;
        }
        .start-button:hover { background-color: #fff; color: #d42426; transform: scale(1.05); box-shadow: 0 0 25px rgba(255, 255, 255, 0.9); }
        
        #game-menu, #settings-menu {
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.95); display: none; 
            flex-direction: column; justify-content: center;
            align-items: center; text-align: center; color: #fff; 
            padding: 20px; box-sizing: border-box; 
        }
        .menu-panel {
            background-color: #1a1a1a; padding: 40px 50px;
            border-radius: 20px; box-shadow: 0 0 40px rgba(212, 36, 38, 0.5); 
            border: 3px solid #165b33; /* Gr√ºner Rahmen */
            max-width: 800px; width: 100%;
            box-sizing: border-box; max-height: 95vh; overflow-y: auto; 
        }
        #game-menu h1, #settings-menu h1 { font-family: 'Orbitron', sans-serif; font-size: 4em; margin-bottom: 15px; letter-spacing: 5px; text-shadow: 0 0 15px #d42426; color: #fff; }
        #game-menu h2, #settings-menu h2 { font-family: 'Orbitron', sans-serif; margin-top: 0; color: #165b33; font-size: 1.8em; letter-spacing: 1px; margin-bottom: 30px; border-bottom: 2px solid #d42426; padding-bottom: 10px; display: inline-block; }
        
        .menu-button {
            background-color: #165b33; /* Gr√ºner Button */
            color: #fff; border: none; 
            padding: 18px 40px; margin: 30px 0 0 0; font-family: 'Orbitron', sans-serif;
            font-size: 2em; font-weight: 700; border-radius: 10px; cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 0 10px rgba(22, 91, 51, 0.5);
        }
        .menu-button:hover { background-color: #d42426; transform: scale(1.05); box-shadow: 0 0 20px rgba(212, 36, 38, 0.7); }
        .menu-button.small-btn { font-size: 1.2em; padding: 12px 25px; margin: 15px 10px; background-color: #333; }
        .menu-button.small-btn:hover { background-color: #165b33; }
        
        .selection-group { margin: 20px 0; padding: 15px; border-radius: 10px; background-color: #2a2a2a; text-align: left; border: 1px solid #444; box-shadow: inset 0 0 8px rgba(0,0,0,0.5); }
        .selection-group h3 { font-family: 'Orbitron', sans-serif; margin-top: 0; color: #d42426; border-bottom: 1px solid #777; padding-bottom: 8px; margin-bottom: 15px; font-size: 1.5em; letter-spacing: 1px; }
        
        .selection-option {
            background-color: #333; color: #eee; padding: 12px 15px; margin-bottom: 8px;
            border-radius: 8px; cursor: pointer; transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
            border: 1px solid #555; font-family: 'Roboto', sans-serif; font-size: 1em; 
            display: flex; align-items: center;
        }
        .selection-option:hover { background-color: #444; border-color: #165b33; }
        .selection-option.selected { 
            background-color: #444; 
            border-color: #d42426; 
            box-shadow: 0 0 8px rgba(212, 36, 38, 0.5), inset 0 0 5px rgba(212, 36, 38, 0.3); 
        }
        .option-icon { margin-right: 12px; font-size: 1.3em; color: #165b33; line-height: 1; }
        .option-text strong { font-family: 'Orbitron', sans-serif; font-weight: 700; font-size: 1em; }
        .option-text span { font-family: 'Roboto', sans-serif; font-weight: 300; font-size: 0.9em; color: #ccc; margin-left: 6px; }
        .selection-option input[type="radio"] { display: none; }
        
        /* KI Toggle Switch Styles (Unver√§ndert) */
        .toggle-switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #165b33; } /* Gr√ºn bei Aktivierung */
        input:checked + .slider:before { transform: translateX(26px); }
        .ai-toggle-option {
            background-color: #333; color: #eee; padding: 12px 15px; margin-bottom: 8px;
            border-radius: 8px; border: 1px solid #555; font-family: 'Roboto', sans-serif; 
            font-size: 1em; display: flex; align-items: center; justify-content: space-between;
        }
        .ai-toggle-text { display: flex; align-items: center; }
        .ai-toggle-text strong { font-family: 'Orbitron', sans-serif; font-weight: 700; font-size: 1em; margin-right: 10px; }

        /* Einstellungen spezifische Styles */
        .setting-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 15px; margin-bottom: 10px; background-color: #3a3a3a;
            border-radius: 8px; border-left: 5px solid #d42426;
            font-family: 'Roboto', sans-serif; font-size: 1.1em;
        }
        .setting-label {
            color: #fff; font-weight: 700;
        }
        .setting-control {
            color: #d42426;
            font-family: 'Orbitron', sans-serif;
            font-weight: 400;
        }
        .setting-control select, .setting-control input {
            padding: 8px; border-radius: 5px; border: 1px solid #165b33;
            background-color: #1a1a1a; color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
        }
        
        /* --- HUD & SONSTIGE ELEMENTE --- */
        #version-text { position: absolute; top: 10px; left: 10px; font-family: 'Roboto', sans-serif; font-size: 1.2em; color: #888; letter-spacing: 1px; z-index: 11; }
        #music-button { background: rgba(0, 0, 0, 0.7); color: #d42426; border: 2px solid #d42426; padding: 10px 15px; border-radius: 5px; cursor: pointer; font-size: 1em; font-weight: bold; }
        #music-button:hover { background: #d42426; color: #fff; }
        #hud {
            top: 20px; right: 20px; font-size: 20px; text-align: right; user-select: none;
            display: none; background: rgba(0, 0, 0, 0.6); padding: 15px 25px;
            border-radius: 10px; border: 2px solid #d42426; box-shadow: 0 0 10px rgba(212, 36, 38, 0.5);
            min-width: 180px; 
        }
        .hud-line { margin-bottom: 5px; color: #fff; }
        #speed-value { font-weight: bold; font-size: 45px; color: #165b33; text-shadow: 0 0 5px #165b33;} /* Gr√ºn f√ºr Speed */
        #drift-angle-value { font-size: 20px; font-weight: bold; color: #ff0000; text-shadow: 0 0 5px #ff0000;}
        #drift-label { color: #d42426; font-size: 16px; }
        #score-line { border-top: 1px solid #444; padding-top: 8px; margin-top: 10px; color: #d42426; font-size: 1.2em; font-weight: 700;}
        #score-value { font-size: 1.8em; color: #fff; text-shadow: 0 0 8px #fff; margin-left: 10px;}
        #multiplier-line { color: #ffd700; font-size: 1.5em; font-weight: 700; text-shadow: 0 0 10px #ffd700;} /* Gold f√ºr Multiplier */
        #multiplier-label { font-size: 0.7em; color: #ffd700; margin-right: 5px;}
        #controls-hud {
            bottom: 20px; left: 20px; font-size: 14px; 
            text-align: left; user-select: none;
            display: none; background: rgba(0, 0, 0, 0.6); 
            padding: 10px 15px; border-radius: 10px; 
            border: 2px solid #165b33; 
            box-shadow: 0 0 10px rgba(22, 91, 51, 0.5);
        }
        .control-line { margin-bottom: 3px; color: #fff; display: flex; align-items: center; font-family: 'Roboto', sans-serif; font-size: 1.1em; }
        .control-key { background: #165b33; color: #fff; padding: 2px 6px; border-radius: 4px; font-weight: bold; margin-right: 8px; font-family: 'Orbitron', sans-serif; border: 1px solid #fff; }
        #madschis-logo {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%); 
            font-family: 'Orbitron', sans-serif; font-size: 2.2em; font-weight: 900;
            letter-spacing: 3px; z-index: 100; display: none; pointer-events: none; 
            /* Weihnachtlicher Gradient */
            background: linear-gradient(to right, #ff0000, #00ff00, #ffd700, #ff0000);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: rainbow-anim 8s linear infinite; text-shadow: 0 0 10px rgba(255,255,255,0.4); 
        }
        @keyframes rainbow-anim { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }
        
        /* MOBILE OPTIMIERUNG */
        @media screen and (max-width: 768px) {
            #start-screen h1 { font-size: 4.5em; letter-spacing: 5px; }
            .start-button { padding: 15px 40px; font-size: 1.8em; margin: 30px 0; }
            #game-menu, #settings-menu { padding: 10px; }
            .menu-panel { padding: 20px 20px; border-radius: 10px; }
            #game-menu h1, #settings-menu h1 { font-size: 3em; letter-spacing: 3px; }
            .menu-button { padding: 15px 30px; font-size: 1.5em; margin: 20px 0 10px 0; }
            #hud { top: 10px; right: 10px; padding: 10px 15px; font-size: 16px; }
            #controls-hud { bottom: 10px; left: 10px; padding: 8px 12px; font-size: 12px; }
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="version-text">Christmas Special (V38)</div>
    
    <div id="start-screen">
        <h1>DRIFT RUSH</h1>
        <p style="color: #ffd700;">üéÖ Christmas Edition üéÑ</p>
        <p>Bereit f√ºr den Weihnachts-Drift?</p>
        <button class="start-button" onclick="startAnimationAndShowMenu()">START</button>
        <button id="music-button" onclick="toggleMusic(true)" style="position: absolute; bottom: 20px; left: 20px; display: block;">Musik: AN üéµ</button>
    </div>

    <div id="game-menu">
        <div class="menu-panel">
            <h1>DRIFT RUSH</h1>
            <h2 style="color: #fff; text-shadow: 0 0 10px #d42426;">FROHE WEIHNACHTEN!</h2>

            <div class="selection-group">
                <h3><span class="option-icon">üéß</span> W√ÑHLE MUSIK</h3>
                <label class="selection-option" data-music="synthwave">
                    <input type="radio" name="music_track" value="synthwave">
                    <span class="option-icon">üåå</span> <span class="option-text"><strong>Synthwave Chill</strong> <span>(Entspannender 80er-Sound)</span></span>
                </label>
                <label class="selection-option" data-music="arcade">
                    <input type="radio" name="music_track" value="arcade" checked>
                    <span class="option-icon">üïπÔ∏è</span> <span class="option-text"><strong>Retro Arcade</strong> <span>(Standard-Gameplay-Beat)</span></span>
                </label>
                <label class="selection-option" data-music="hard_rock">
                    <input type="radio" name="music_track" value="hard_rock">
                    <span class="option-icon">ü§ò</span> <span class="option-text"><strong>Hard Rock Beat</strong> <span>(H√§rterer, tieferer Sound)</span></span>
                </label>
            </div>


            <div class="selection-group">
                <h3><span class="option-icon">üöó</span> W√ÑHLE SCHLITTEN (AUTO)</h3>
                <label class="selection-option" data-car="drift_racer">
                    <input type="radio" name="car_model" value="drift_racer" checked>
                    <span class="option-icon">üî∑</span> <span class="option-text"><strong>Drift Racer</strong> <span>(Beste Balance f√ºr Grip & Drift)</span></span>
                </label>
                <label class="selection-option" data-car="muscle_car">
                    <input type="radio" name="car_model" value="muscle_car">
                    <span class="option-icon">üî¥</span> <span class="option-text"><strong>Muscle Car</strong> <span>(Hohe Power, leichter zu driften)</span></span>
                </label>
                <label class="selection-option" data-car="sport_coupe">
                    <input type="radio" name="car_model" value="sport_coupe">
                    <span class="option-icon">üü°</span> <span class="option-text"><strong>Sport Coup√©</strong> <span>(Ausgeglichenes Fahren, hohe Stabilit√§t)</span></span>
                </label>
                <label class="selection-option" data-car="heavy_truck">
                    <input type="radio" name="car_model" value="heavy_truck">
                    <span class="option-icon">üü¢</span> <span class="option-text"><strong>Heavy Truck</strong> <span>(Langsam, hohe Masse)</span></span>
                </label>
                <label class="selection-option" data-car="supercar">
                    <input type="radio" name="car_model" value="supercar">
                    <span class="option-icon">üíñ</span> <span class="option-text"><strong>Supercar</strong> <span>(Extrem schnell, geringer Grip)</span></span>
                </label>
                <label class="selection-option" data-car="rally_car">
                    <input type="radio" name="car_model" value="rally_car">
                    <span class="option-icon">üåø</span> <span class="option-text"><strong>Rally Car</strong> <span>(Hoher Grip, perfekte Kurven)</span></span>
                </label>
            </div>
            
            <div class="selection-group">
                <h3><span class="option-icon">‚ùÑÔ∏è</span> W√ÑHLE MAP</h3>
                <label class="selection-option" data-map="snow_drift_area">
                    <input type="radio" name="map_name" value="snow_drift_area" checked>
                    <span class="option-icon">‚ùÑÔ∏è</span> <span class="option-text"><strong>Schnee-Drift-Fl√§che</strong> <span>(Das volle Winter-Erlebnis)</span></span>
                </label>
                <label class="selection-option" data-map="parking_lot">
                    <input type="radio" name="map_name" value="parking_lot">
                    <span class="option-icon">üÖøÔ∏è</span> <span class="option-text"><strong>Verschneiter Parkplatz</strong> <span>(Mit Laternen und Eis)</span></span>
                </label>
                <label class="selection-option" data-map="race_track">
                    <input type="radio" name="map_name" value="race_track">
                    <span class="option-icon">üèÅ</span> <span class="option-text"><strong>Eis-Rennstrecke</strong> <span>(Rutschige Kurven)</span></span>
                </label>
                <label class="selection-option" data-map="building_city">
                    <input type="radio" name="map_name" value="building_city">
                    <span class="option-icon">üèôÔ∏è</span> <span class="option-text"><strong>Winter Stadt</strong> <span>(Kurven zwischen Geb√§uden)</span></span>
                </label>
                <label class="selection-option" data-map="simple_parking_lot">
                    <input type="radio" name="map_name" value="simple_parking_lot">
                    <span class="option-icon">üöó</span> <span class="option-text"><strong>Kleiner Eisparkplatz</strong> <span>(Kompakt)</span></span>
                </label>
            </div>
            
            <div class="selection-group">
                <h3><span class="option-icon">ü§ñ</span> KI-GEGNER</h3>
                <div class="ai-toggle-option">
                    <div class="ai-toggle-text">
                        <strong>KI-Gegner einschalten</strong> 
                        <span id="ai-status"> (AN) </span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="ai-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            
            <p style="font-family: 'Roboto', sans-serif; font-size: 1.1em; color: #fff; margin-top: 30px;">
                <span style="color: #d42426; font-weight: bold;">Steuerung:</span> Beschleunigen (<kbd>W</kbd>), Bremsen/R√ºckw√§rts (<kbd>S</kbd>), Lenken (<kbd>A</kbd>/<kbd>D</kbd>), Handbremse (<kbd>Space</kbd>).
            </p>

            <button class="menu-button small-btn" onclick="showSettings()">EINSTELLUNGEN ‚öôÔ∏è</button>
            <button class="menu-button" onclick="startGame()">LOS GEHT'S üéÑ</button>
        </div>
    </div>
    
    <div id="settings-menu">
        <div class="menu-panel">
            <h1>DRIFT RUSH</h1>
            <h2>EINSTELLUNGEN ‚öôÔ∏è</h2>
            
            <div class="selection-group">
                <h3><span class="option-icon">üíª</span> GRAFIK & PERFORMANCE</h3>
                
                <div class="setting-item">
                    <span class="setting-label">Qualit√§t</span>
                    <span class="setting-control">
                        <select id="setting-quality">
                            <option value="ultra">Ultra (Beste Grafik)</option>
                            <option value="high" selected>Hoch (Ausgewogen)</option>
                            <option value="medium">Mittel (Gute Performance)</option>
                            <option value="low">Niedrig (Beste Performance)</option>
                        </select>
                    </span>
                </div>
                
                <div class="setting-item">
                    <span class="setting-label">Schattenqualit√§t</span>
                    <span class="setting-control">
                        <select id="setting-shadows">
                            <option value="high" selected>Hoch</option>
                            <option value="medium">Mittel</option>
                            <option value="off">Aus</option>
                        </select>
                    </span>
                </div>
                
                <div class="setting-item">
                    <span class="setting-label">Baum-Anzahl</span>
                    <span class="setting-control">
                        <select id="setting-trees">
                            <option value="high" selected>Viele (Weihnachtswald)</option>
                            <option value="low">Wenige</option>
                            <option value="off">Keine</option>
                        </select>
                    </span>
                </div>
            </div>

            <div class="selection-group">
                <h3><span class="option-icon">üîä</span> AUDIO</h3>
                <div class="setting-item">
                    <span class="setting-label">Haupt-Lautst√§rke</span>
                    <span class="setting-control">
                        <input type="range" id="setting-master-volume" min="0" max="100" value="70">
                    </span>
                </div>
            </div>

            <button class="menu-button" onclick="applySettingsAndShowMenu()">SPEICHERN & ZUR√úCK</button>
        </div>
    </div>

    <div id="hud">
        <div id="multiplier-line" style="display:none;">
            <span id="multiplier-label">X</span><span id="multiplier-value">1</span>
        </div>
        <div id="score-line">
            SCORE <span id="score-value">0</span>
        </div>
        <hr style="border-color:#444;">
        
        <div class="hud-line">
            GESCHWINDIGKEIT KM/H
        </div>
        <div class="hud-line">
            <span id="speed-value">0</span>
        </div>
        <div class="hud-line">
            <span id="drift-label">DRIFT-WINKEL</span>
        </div>
        <div class="hud-line">
            <span id="drift-angle-value">0¬∞</span>
        </div>
        <button id="music-button" onclick="toggleMusic(false)" style="display:none;"></button>
    </div>
    
    <div id="controls-hud">
        <div style="font-family: 'Orbitron', sans-serif; font-weight: 700; color: #165b33; margin-bottom: 5px; font-size: 1.2em;">STEUERUNG</div>
        <div class="control-line"><span class="control-key">W</span> Beschleunigen</div>
        <div class="control-line"><span class="control-key">S</span> Bremsen / R√ºckw√§rts</div>
        <div class="control-line"><span class="control-key">A</span> Links lenken</div>
        <div class="control-line"><span class="control-key">D</span> Rechts lenken</div>
        <div class="control-line"><span class="control-key">SPACE</span> Handbremse (Drift)</div>
    </div>
    
    <div id="madschis-logo">MADSCHI</div> 

    <audio id="music-synthwave" loop>
        <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-8.mp3" type="audio/mpeg">
    </audio>
    <audio id="music-arcade" loop>
        <source src="https://ia800900.us.archive.org/1/items/arcade_audio/arcade_audio.mp3" type="audio/mpeg">
    </audio>
    <audio id="music-hard_rock" loop>
        <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3" type="audio/mpeg">
    </audio>
    
    <audio id="sound-engine" loop preload="auto">
        <source src="https://actions.google.com/sounds/v1/vehicles/sports_car_accelerate_and_decelerate.ogg" type="type/ogg">
    </audio>
    <audio id="sound-skid" loop preload="auto">
        <source src="https://actions.google.com/sounds/v1/vehicles/skidding.ogg" type="audio/ogg">
    </audio>
    <audio id="sound-collision" preload="auto">
        <source src="https://actions.google.com/sounds/v1/impacts/impact_whack_light.ogg" type="audio/ogg">
    </audio>


    <script>
        // GLOBALE VARIABLEN
        const GAME_VERSION = "Christmas Special (V38)"; // <<< GE√ÑNDERT
        let scene, camera, renderer;
        let car; 
        let ambientLight, sunLight;
        const keys = {};
        const clock = new THREE.Clock();
        let isGameRunning = false;
        let isAnimationLoopRunning = false; 
        
        const trackSize = 250; 
        const trackY = 0.1; 
        const grassY = 0; 
        
        const CAR_SCALE = 1.5; 
        
        const cameraBaseOffset = new THREE.Vector3(0, 8 * CAR_SCALE, -15 * CAR_SCALE); 
        const cameraZoomDriftFactor = 0.005; 
        
        let velocity = new THREE.Vector3(0, 0, 0); 
        let currentCarMass = 1; 
        
        let skidMarkTimer = 0;
        const skidMarkDelay = 0.05;
        let leftMarkPosition = new THREE.Vector3();
        let rightMarkPosition = new THREE.Vector3();
        let currentScore = 0;
        let currentDriftPoints = 0; 
        let driftMultiplier = 1;
        let isDrifting = false;
        let lastDriftEnd = 0; 
        const multiplierResetTime = 2.0; 

        let currentMusicTrack = null;
        let MUSIC_VOLUME = 0.3; // Einstellbar
        
        // KI Variablen
        let aiCars = [];
        let waypoints = [];
        let isAIToggledOn = true;
        
        // Sound-Variablen
        let engineSound = null;
        let skidSound = null;
        let collisionSound = null;
        const ENGINE_VOLUME = 0.5;
        const SKID_VOLUME_MAX = 0.8;
        const COLLISION_VOLUME = 1.0;
        let masterVolume = 0.7; 
        
        // Globale Physik-Modifikatoren f√ºr Maps
        let currentMapPhysics = {
            longitudinalGripFactor: 1.0, 
            sideGripFactor: 1.0,         
        };
        let currentMapName = 'parking_lot'; 

        // Einstellungen
        let gameSettings = {
            quality: 'high',
            shadows: 'high',
            trees: 'high',
            masterVolume: 70
        };


        // Auto-Konfigurationen
        const carConfigs = {
            'drift_racer': {
                color: 0x0000ff,
                mass: 1.5,
                maxPower: 160,
                brakeForce: 250,
                steerAngle: Math.PI / 10,
                steerSpeed: 3.5,
                longitudinalGrip: 0.9,
                sideGrip: 0.75,
                handbrakeFactor: 0.2,
                aiSpeed: 30
            },
            'muscle_car': {
                color: 0xff0000,
                mass: 2.0,
                maxPower: 220,
                brakeForce: 180,
                steerAngle: Math.PI / 16,
                steerSpeed: 2.5,
                longitudinalGrip: 0.8,
                sideGrip: 0.60,
                handbrakeFactor: 0.1,
                aiSpeed: 35
            },
            'sport_coupe': {
                color: 0xffcc00,
                mass: 1.2,
                maxPower: 180,
                brakeForce: 300,
                steerAngle: Math.PI / 12,
                steerSpeed: 4.0,
                longitudinalGrip: 0.95,
                sideGrip: 0.85,
                handbrakeFactor: 0.3,
                aiSpeed: 25
            },
            'heavy_truck': {
                color: 0x38761d,
                mass: 5.0,
                maxPower: 100,
                brakeForce: 400,
                steerAngle: Math.PI / 20,
                steerSpeed: 1.5,
                longitudinalGrip: 0.99,
                sideGrip: 0.95,
                handbrakeFactor: 0.5,
                aiSpeed: 20
            },
            'supercar': {
                color: 0xff0080,
                mass: 1.0,
                maxPower: 250,
                brakeForce: 350,
                steerAngle: Math.PI / 8,
                steerSpeed: 5.0,
                longitudinalGrip: 0.85,
                sideGrip: 0.65,
                handbrakeFactor: 0.15,
                aiSpeed: 40
            },
            'rally_car': {
                color: 0x00ff80,
                mass: 1.8,
                maxPower: 200,
                brakeForce: 280,
                steerAngle: Math.PI / 9,
                steerSpeed: 4.5,
                longitudinalGrip: 0.98,
                sideGrip: 0.90,
                handbrakeFactor: 0.25,
                aiSpeed: 28
            }
        };

        let currentCarConfig = carConfigs['drift_racer']; 
        
        // KI Car Klasse (Verbesserung in der Update-Methode)
        class AICar {
            constructor(configName, color, waypoints) {
                this.config = carConfigs[configName];
                this.mesh = createCarModel(color, true); 
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.pathIndex = 0; 
                this.waypoints = waypoints;
                this.mesh.position.set(waypoints[0].x, trackY + (0.5 * CAR_SCALE), waypoints[0].z);
                this.mesh.rotation.y = -Math.PI / 2; 
            }
            
            // Bessere KI-Logik (V38)
            update(deltaTime) {
                if (this.waypoints.length === 0) return;

                const currentWaypoint = this.waypoints[this.pathIndex];
                const nextIndex = (this.pathIndex + 1) % this.waypoints.length;
                const nextWaypoint = this.waypoints[nextIndex];
                
                const currentPos = this.mesh.position;
                const targetPosition = new THREE.Vector3(currentWaypoint.x, currentPos.y, currentWaypoint.z);
                const nextPosition = new THREE.Vector3(nextWaypoint.x, currentPos.y, nextWaypoint.z);

                // 1. Ziel-Wegpunkt-Update
                const distanceToCurrent = currentPos.distanceTo(targetPosition);
                const waypointTolerance = 15; 
                
                if (distanceToCurrent < waypointTolerance) { 
                    this.pathIndex = nextIndex;
                }
                
                // 2. Look-Ahead Punkt berechnen
                const lookAheadDistance = 30 + this.velocity.length() * 0.5; // Dynamisch basierend auf Geschwindigkeit
                const directionToNext = nextPosition.clone().sub(targetPosition).normalize();
                
                const curveAdjustment = 20; // St√§rkere Korrektur f√ºr Rennstrecke
                
                let targetPoint = targetPosition.clone();
                targetPoint.addScaledVector(directionToNext, lookAheadDistance);
                
                // 3. Ideallinien-Anpassung (Offset zur Innenseite der Kurve)
                if (this.pathIndex % 2 !== 0 && currentMapName === 'race_track') { // Annahme: Jede zweite Kurve
                     const forwardWaypoint = nextPosition.clone().sub(targetPosition).normalize();
                     const normalVector = new THREE.Vector3(0, 1, 0).cross(forwardWaypoint).normalize();
                     // Offset nach innen (abh√§ngig von der Richtung)
                     if (forwardWaypoint.x > 0) { 
                          targetPoint.addScaledVector(normalVector, -curveAdjustment);
                     } else {
                          targetPoint.addScaledVector(normalVector, curveAdjustment);
                     }
                }
                

                // 4. Geschwindigkeitskontrolle
                const currentSpeed = this.velocity.length();
                let targetSpeed = this.config.aiSpeed;
                
                // Bremsen f√ºr Kurven (basierend auf der Entfernung zum n√§chsten Punkt, wenn er sehr nahe ist)
                if (distanceToCurrent < 40) {
                     const brakeFactor = 1 - (distanceToCurrent / 40); 
                     targetSpeed = this.config.aiSpeed * (1 - (brakeFactor * 0.8)); 
                }
                
                let acceleration = 0;
                if (currentSpeed < targetSpeed) {
                    acceleration = 1; 
                } else if (currentSpeed > targetSpeed + 0.5) {
                    acceleration = -0.8; // Aggressiveres Bremsen/Abbremsen
                }
                
                // 5. Lenkung (Steering)
                const toTarget = targetPoint.clone().sub(currentPos).normalize();
                const currentForward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion);

                const angleToTarget = currentForward.angleTo(toTarget);
                const axis = new THREE.Vector3(0, 1, 0); 
                const rotationDirection = currentForward.clone().cross(toTarget).dot(axis) > 0 ? 1 : -1;
                
                if (angleToTarget > 0.05) {
                    const maxSteer = this.config.steerAngle; 
                    const steerFactor = Math.min(1, angleToTarget / (Math.PI / 6)); 
                    const steerRate = rotationDirection * maxSteer * steerFactor * this.config.steerSpeed * deltaTime;
                    this.mesh.rotation.y += steerRate;
                }
                
                // 6. Drift-Korrektur (Bessere Ausrichtung des Autos zur Geschwindigkeit)
                const velocityDirection = this.velocity.clone().normalize();
                const speedAngle = currentForward.angleTo(velocityDirection);
                
                if (speedAngle > 0.1 && currentSpeed > 10) { 
                    const correctionAxis = new THREE.Vector3(0, 1, 0); 
                    const correctionDirection = currentForward.clone().cross(velocityDirection).dot(correctionAxis) > 0 ? -1 : 1; 
                    this.mesh.rotation.y += correctionDirection * speedAngle * 1.5 * deltaTime; // St√§rkere Korrektur
                }


                // 7. Physik-Berechnung
                const maxPower = this.config.maxPower * 0.7; // KI f√§hrt nicht mit voller Leistung
                const driveForce = maxPower * acceleration;
                
                let totalForce = new THREE.Vector3();
                totalForce.addScaledVector(currentForward, driveForce);
                
                // Reibung/Widerstand
                totalForce.addScaledVector(this.velocity, -0.6 * this.config.mass); 

                const accelerationVector = totalForce.divideScalar(this.config.mass);
                this.velocity.addScaledVector(accelerationVector, deltaTime);

                // Max Speed Begrenzung
                const maxAISpeed = this.config.aiSpeed * 1.5; 
                if (this.velocity.length() > maxAISpeed) {
                     this.velocity.setLength(maxAISpeed);
                }


                this.mesh.position.addScaledVector(this.velocity, deltaTime);
                this.mesh.position.y = trackY + (0.5 * CAR_SCALE); 
            }
        }
        
        // Waypoint Daten
        const mapWaypoints = {
            'parking_lot': [
                { x: 0, z: 50 }, { x: 50, z: 50 }, { x: 50, z: -50 }, { x: -50, z: -50 }, { x: -50, z: 50 }
            ],
            'race_track': [
                { x: 0, z: 120 }, { x: 100, z: 120 }, { x: 140, z: 80 }, { x: 140, z: -80 }, { x: 100, z: -120 },
                { x: -100, z: -120 }, { x: -140, z: -80 }, { x: -140, z: 80 }, { x: -100, z: 120 }
            ],
            'snow_drift_area': [
                { x: 0, z: 0 }
            ],
            'building_city': [
                { x: 0, z: 100 }, { x: 80, z: 100 }, { x: 100, z: 80 }, { x: 100, z: 0 }, { x: 80, z: -20 },
                { x: 40, z: -20 }, { x: 20, z: 0 }, { x: 20, z: 80 }, { x: -20, z: 80 }, { x: -20, z: 0 },
                { x: -40, z: -20 }, { x: -80, z: -20 }, { x: -100, z: 0 }, { x: -100, z: 80 }, { x: -80, z: 100 },
                { x: 0, z: 100 }
            ],
            'simple_parking_lot': [
                { x: 0, z: 30 }, { x: 30, z: 30 }, { x: 30, z: -30 }, { x: -30, z: -30 }, { x: -30, z: 30 }
            ]
        };
        
        // --- MEN√ú, EINSTELLUNGEN & MUSIK FUNKTIONEN ---
        
        document.getElementById('version-text').textContent = "Version " + GAME_VERSION;
        
        function loadSettings() {
            const storedSettings = localStorage.getItem('driftRushSettings');
            if (storedSettings) {
                gameSettings = JSON.parse(storedSettings);
            }
            masterVolume = gameSettings.masterVolume / 100;
        }

        function applySettingsToGame() {
            if (sunLight) {
                const shadowSetting = gameSettings.shadows;
                sunLight.castShadow = shadowSetting !== 'off';
                if (renderer) {
                    renderer.shadowMap.enabled = sunLight.castShadow;
                }
            }
            masterVolume = gameSettings.masterVolume / 100;
            updateAllVolumes();
        }
        
        function updateAllVolumes() {
            const musicTracks = ['music-synthwave', 'music-arcade', 'music-hard_rock'];
            musicTracks.forEach(id => {
                const track = document.getElementById(id);
                if (track) track.volume = MUSIC_VOLUME * masterVolume;
            });

            if (engineSound) engineSound.volume = ENGINE_VOLUME * masterVolume;
            if (skidSound) skidSound.volume = SKID_VOLUME_MAX * masterVolume;
            if (collisionSound) collisionSound.volume = COLLISION_VOLUME * masterVolume;
        }

        function setupSettingsMenu() {
            document.getElementById('setting-quality').value = gameSettings.quality;
            document.getElementById('setting-shadows').value = gameSettings.shadows;
            document.getElementById('setting-trees').value = gameSettings.trees;
            document.getElementById('setting-master-volume').value = gameSettings.masterVolume;
        }

        function showSettings() {
            document.getElementById('game-menu').style.display = 'none';
            setupSettingsMenu();
            document.getElementById('settings-menu').style.display = 'flex';
        }

        function applySettingsAndShowMenu() {
            gameSettings.quality = document.getElementById('setting-quality').value;
            gameSettings.shadows = document.getElementById('setting-shadows').value;
            gameSettings.trees = document.getElementById('setting-trees').value;
            gameSettings.masterVolume = parseInt(document.getElementById('setting-master-volume').value);
            
            localStorage.setItem('driftRushSettings', JSON.stringify(gameSettings));

            applySettingsToGame();
            document.getElementById('settings-menu').style.display = 'none';
            document.getElementById('game-menu').style.display = 'flex';
        }

        function setupSounds() {
            engineSound = document.getElementById('sound-engine');
            skidSound = document.getElementById('sound-skid');
            collisionSound = document.getElementById('sound-collision');
            
            engineSound.volume = 0;
            engineSound.loop = true;
            engineSound.playbackRate = 0.5;
            
            skidSound.volume = 0;
            skidSound.loop = true;
            
            collisionSound.volume = COLLISION_VOLUME * masterVolume;
            
            const musicTracks = ['music-synthwave', 'music-arcade', 'music-hard_rock'];
            musicTracks.forEach(id => {
                const track = document.getElementById(id);
                if (track) track.volume = MUSIC_VOLUME * masterVolume;
            });
        }
        
        function playEngineSound() {
            if (engineSound && engineSound.paused) {
                engineSound.play().catch(e => console.log("Engine sound start failed:", e));
            }
            if (skidSound && skidSound.paused) {
                skidSound.play().catch(e => console.log("Skid sound start failed:", e));
            }
        }

        function updateGameSounds(speedKPH, driftAngle, deltaTime) {
            const speedFactor = Math.min(1, speedKPH / 100);
            if (engineSound) {
                engineSound.volume = ENGINE_VOLUME * speedFactor * masterVolume;
                engineSound.playbackRate = 0.5 + speedFactor * 1.5;
            }

            const driftThreshold = 15;
            const driftFactor = THREE.MathUtils.clamp((driftAngle - driftThreshold) / 30, 0, 1);
            if (skidSound) {
                skidSound.volume = SKID_VOLUME_MAX * driftFactor * masterVolume;
            }
        }

        // Stabilere Men√º-Auswahl Logik 
        function setupSelectionListeners() {
            document.querySelectorAll('.selection-option').forEach(option => {
                option.addEventListener('click', function(event) {
                    event.preventDefault(); 
                    
                    const radio = this.querySelector('input[type="radio"]');
                    if (radio) {
                        
                        radio.checked = true;
                        
                        const radioName = radio.name;
                        document.querySelectorAll(`input[name="${radioName}"]`).forEach(otherRadio => {
                            otherRadio.closest('.selection-option').classList.remove('selected');
                        });
                        
                        this.classList.add('selected');

                        if (radioName === 'music_track' && currentMusicTrack) {
                            if (isMusicPlaying) {
                                if (currentMusicTrack) currentMusicTrack.pause();
                                const newTrackId = 'music-' + radio.value;
                                currentMusicTrack = document.getElementById(newTrackId);
                                if (currentMusicTrack) {
                                    currentMusicTrack.currentTime = 0;
                                    currentMusicTrack.play().catch(e => console.log("Musikwechsel fehlgeschlagen."));
                                }
                            }
                        }
                    }
                });
            });

            document.querySelectorAll('input[type="radio"]:checked').forEach(radio => {
                radio.closest('.selection-option').classList.add('selected');
            });
            
            const aiToggle = document.getElementById('ai-toggle');
            const aiStatusText = document.getElementById('ai-status');
            aiToggle.addEventListener('change', function() {
                isAIToggledOn = this.checked;
                aiStatusText.textContent = isAIToggledOn ? ' (AN)' : ' (AUS)';
            });
            isAIToggledOn = aiToggle.checked;
            aiStatusText.textContent = isAIToggledOn ? ' (AN)' : ' (AUS)';
        }

        let isMusicPlaying = true;

        function toggleMusic(isLobby) {
            const button = document.getElementById('music-button');
            if (isMusicPlaying) {
                if (currentMusicTrack) currentMusicTrack.pause();
                isMusicPlaying = false;
                button.textContent = "Musik: AUS üîá";
            } else {
                if (isLobby) {
                    const selectedTrack = document.querySelector('input[name="music_track"]:checked');
                    const trackId = selectedTrack ? 'music-' + selectedTrack.value : 'music-arcade';
                    currentMusicTrack = document.getElementById(trackId);
                } else {
                    currentMusicTrack = document.getElementById('music-' + document.querySelector('input[name="music_track"]:checked').value);
                }
                
                if (currentMusicTrack) {
                    currentMusicTrack.currentTime = 0;
                    currentMusicTrack.play().catch(e => console.log("Musik konnte nicht automatisch gestartet werden."));
                }
                isMusicPlaying = true;
                button.textContent = "Musik: AN üéµ";
            }
            updateAllVolumes();
        }

        function switchMusicToGame() {
            // Alte Tracks pausieren
            document.getElementById('music-synthwave').pause();
            document.getElementById('music-arcade').pause();
            document.getElementById('music-hard_rock').pause();

            const selectedTrackId = 'music-' + document.querySelector('input[name="music_track"]:checked').value;
            const gameMusic = document.getElementById(selectedTrackId);
            currentMusicTrack = gameMusic;

            if (isMusicPlaying && currentMusicTrack) {
                currentMusicTrack.currentTime = 0;
                currentMusicTrack.play();
            }

            const musicButton = document.getElementById('music-button');
            document.getElementById('hud').appendChild(musicButton);
            musicButton.style.display = 'block';
            musicButton.style.position = 'relative';
            musicButton.style.bottom = 'auto';
            musicButton.style.left = 'auto';
            musicButton.style.marginTop = '10px';
        }

        // Stabilere Initialisierung
        function startAnimationAndShowMenu() {
            // 1. Initialisierung der 3D-Welt, falls noch nicht geschehen
            if (!renderer) {
                initializeCoreSystems();
            }
            
            // 2. Laden der gespeicherten Einstellungen
            loadSettings();
            
            // 3. Men√º-Zuh√∂rer und Standard-Sounds setzen
            setupSelectionListeners();
            setupSounds();
            applySettingsToGame(); // Aktualisiert Lautst√§rke, Schatten etc.

            // 4. Lobby-Musik starten
            const selectedTrack = document.querySelector('input[name="music_track"]:checked');
            const trackId = selectedTrack ? 'music-' + selectedTrack.value : 'music-arcade';
            currentMusicTrack = document.getElementById(trackId);
            
            if (isMusicPlaying && currentMusicTrack) {
                currentMusicTrack.currentTime = 0;
                currentMusicTrack.play().catch(e => console.log("Men√º-Musik konnte nicht automatisch gestartet werden."));
            }

            // 5. √úbergang zum Men√º-Bildschirm
            const startScreen = document.getElementById('start-screen');
            startScreen.style.opacity = '0';
            setTimeout(() => {
                startScreen.style.display = 'none';
                document.getElementById('game-menu').style.display = 'flex';
            }, 1000);
        }
        
        // --- KERNFUNKTIONEN --- 

        function startGame() {
            const selectedCarId = document.querySelector('input[name="car_model"]:checked').value;
            const selectedMapName = document.querySelector('input[name="map_name"]:checked').value;
            currentMapName = selectedMapName; 

            currentCarConfig = carConfigs[selectedCarId];
            currentCarMass = currentCarConfig.mass;
            
            currentScore = 0;
            currentDriftPoints = 0;
            driftMultiplier = 1;
            isDrifting = false;
            lastDriftEnd = 0;

            document.getElementById('game-menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('controls-hud').style.display = 'block';
            document.getElementById('madschis-logo').style.display = 'block';

            switchMusicToGame();
            playEngineSound();
            
            loadGame(selectedMapName);
            
            if (isAIToggledOn && selectedMapName !== 'snow_drift_area') { 
                createAICars();
            }

            isGameRunning = true;

            window.removeEventListener('keydown', onKeyDown, false);
            window.removeEventListener('keyup', onKeyUp, false);
            window.addEventListener('keydown', onKeyDown, false);
            window.addEventListener('keyup', onKeyUp, false);
        }

        // HIMMEL/FOG HINZUGEF√úGT
        function initializeCoreSystems() {
            if (renderer) return;

            scene = new THREE.Scene();
            // WINTER HIMMEL (Grau-Blau)
            const winterColor = 0xcceeff;
            scene.background = new THREE.Color(winterColor); 
            scene.fog = new THREE.Fog(winterColor, 100, 400); 
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.body.appendChild(renderer.domElement);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Helleres Ambient f√ºr Schnee
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffee, 3.0); // Kaltes Sonnenlicht
            sunLight.position.set(200, 150, 100);
            sunLight.castShadow = true;

            sunLight.shadow.mapSize.width = 2048; 
            sunLight.shadow.mapSize.height = 2048;
            
            const d = trackSize; 
            sunLight.shadow.camera.left = -d;
            sunLight.shadow.camera.right = d;
            sunLight.shadow.camera.top = d;
            sunLight.shadow.camera.bottom = -d;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 500;
            scene.add(sunLight);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            window.addEventListener('resize', onWindowResize, false);
            
            if (!isAnimationLoopRunning) {
                isAnimationLoopRunning = true;
                animate(); 
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // NEU: Weihnachtliche Lichterketten am Auto
        function createChristmasLights(carGroup) {
            const lightColors = [0xff0000, 0x00ff00, 0xffd700, 0x0000ff]; // Rot, Gr√ºn, Gold, Blau
            const numLights = 16;
            const length = 4.5 * CAR_SCALE;
            const width = 2.5 * CAR_SCALE;
            const height = 1.2 * CAR_SCALE;
            
            for(let i = 0; i < numLights; i++) {
                const color = lightColors[i % lightColors.length];
                const bulbGeo = new THREE.SphereGeometry(0.1, 8, 8);
                const bulbMat = new THREE.MeshBasicMaterial({ color: color });
                const bulb = new THREE.Mesh(bulbGeo, bulbMat);
                
                // Positionierung entlang der Seiten
                const side = i < numLights/2 ? 1 : -1;
                const posAlong = ((i % (numLights/2)) / (numLights/2)) * length - length/2 + 0.2;
                
                bulb.position.set(side * (width/2 + 0.05), height - 0.2, posAlong);
                carGroup.add(bulb);
            }
        }

        function createCarModel(color, isAI) {
            const carGroup = new THREE.Group();
            
            const bodyGeometry = new THREE.BoxGeometry(2.5 * CAR_SCALE, 1.2 * CAR_SCALE, 4.5 * CAR_SCALE);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: color, metalness: 0.5, roughness: 0.4 });
            const carBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            carBody.position.y = 0.6 * CAR_SCALE; 
            carBody.castShadow = true;
            carGroup.add(carBody);
            
            // <<< NEU: Lichterketten hinzuf√ºgen
            createChristmasLights(carGroup);

            const cabinGeometry = new THREE.BoxGeometry(2 * CAR_SCALE, 0.8 * CAR_SCALE, 1.8 * CAR_SCALE);
            const cabinMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.2, roughness: 0.7 });
            const carCabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            carCabin.position.y = 1.3 * CAR_SCALE;
            carCabin.position.z = 0.3 * CAR_SCALE;
            carCabin.castShadow = true;
            carGroup.add(carCabin);
            
            if (!isAI) {
                const headLightGeometry = new THREE.CircleGeometry(0.15 * CAR_SCALE, 8);
                const headLightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const headlightLeft = new THREE.Mesh(headLightGeometry, headLightMaterial);
                headlightLeft.rotation.y = Math.PI / 2;
                headlightLeft.position.set(-1.25 * CAR_SCALE, 0.6 * CAR_SCALE, 2.25 * CAR_SCALE);
                carGroup.add(headlightLeft);
                const headlightRight = new THREE.Mesh(headLightGeometry, headLightMaterial);
                headlightRight.rotation.y = Math.PI / 2;
                headlightRight.position.set(1.25 * CAR_SCALE, 0.6 * CAR_SCALE, 2.25 * CAR_SCALE);
                carGroup.add(headlightRight);
            }

            const wheelGeometry = new THREE.CylinderGeometry(0.5 * CAR_SCALE, 0.5 * CAR_SCALE, 0.3 * CAR_SCALE, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });

            const wheels = [];
            const wheelPositions = [
                { x: 1.5 * CAR_SCALE, z: 1.5 * CAR_SCALE },
                { x: -1.5 * CAR_SCALE, z: 1.5 * CAR_SCALE },
                { x: 1.5 * CAR_SCALE, z: -1.5 * CAR_SCALE },
                { x: -1.5 * CAR_SCALE, z: -1.5 * CAR_SCALE }
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2; 
                wheel.position.set(pos.x, 0.5 * CAR_SCALE, pos.z);
                wheel.castShadow = true;
                wheel.receiveShadow = true; 
                carGroup.add(wheel);
                wheels.push(wheel);
            });
            
            if (!isAI) {
                carGroup.getObjectByName = function(name) {
                    if (name === 'frontLeftWheel') return wheels[1];
                    if (name === 'frontRightWheel') return wheels[0];
                    return null;
                };
            }

            return carGroup;
        }
        
        // Laternenpfahl-Funktion (unver√§ndert aus V36)
        function createLamppost(x, z) {
            const lamppostGroup = new THREE.Group();
            
            // 1. Post (Trunk)
            const postHeight = 15;
            const postRadius = 0.2;
            const postGeometry = new THREE.CylinderGeometry(postRadius, postRadius, postHeight, 8);
            const postMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = postHeight / 2 + trackY;
            post.castShadow = true;
            lamppostGroup.add(post);

            // 2. Lamp Head (Cube)
            const headGeometry = new THREE.BoxGeometry(1.5, 0.5, 1.5);
            const headMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = postHeight + trackY;
            head.castShadow = true;
            lamppostGroup.add(head);
            
            // 3. Light Source (PointLight)
            const light = new THREE.PointLight(0xffccaa, 2.5, 60, 2); // Warmes Licht
            light.position.set(0, postHeight - 1 + trackY, 0); 
            light.castShadow = true; 
            light.shadow.mapSize.width = 1024;
            light.shadow.mapSize.height = 1024;
            light.shadow.camera.near = 0.5;
            light.shadow.camera.far = 60;
            lamppostGroup.add(light);
            
            lamppostGroup.position.set(x, 0, z);
            scene.add(lamppostGroup);
        }
        
        // Parkplatz-Linien-Funktion (unver√§ndert aus V36)
        function createParkingLines(parkingLotSize) {
            const lines = new THREE.Group();
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // Wei√üe Linien
            const lineThickness = 0.1;
            const lineLength = 5;
            const spacing = 7; // Abstand zwischen den Linien
            const numLines = Math.floor((parkingLotSize * 2) / spacing);
            const startX = -parkingLotSize;
            const startY = trackY + 0.05; 
            
            // L√§ngsreihen (Parallel zur Z-Achse)
            for (let i = 1; i < numLines; i++) {
                const xPos = startX + spacing * i;
                
                // 1. Reihe (Oben/Mitte)
                for(let j = 0; j < 10; j++) {
                    const zPos = parkingLotSize - 20 - j * (lineLength + 1);
                    const lineGeometry = new THREE.BoxGeometry(lineThickness, 0.01, lineLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.position.set(xPos, startY, zPos);
                    lines.add(line);
                }

                // 2. Reihe (Unten/Mitte)
                for(let j = 0; j < 10; j++) {
                    const zPos = -parkingLotSize + 20 + j * (lineLength + 1);
                    const lineGeometry = new THREE.BoxGeometry(lineThickness, 0.01, lineLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.position.set(xPos, startY, zPos);
                    lines.add(line);
                }
            }
            scene.add(lines);
        }
        
        // V37: Curbs f√ºr Rennstrecke (Unver√§ndert)
        function createCurbs(centerPath) {
            const pathPoints = centerPath.getPoints(200);
            const tubularSegments = pathPoints.length;
            const radius = 20; // Halbe Stra√üenbreite (Gesamtbreite 40)
            const curbSize = 1.0; 
            const curbHeight = 0.3;
            const colors = [0xff0000, 0xffffff]; // Rot und Wei√ü
            
            const curbsGroup = new THREE.Group();

            const roadGeometry = new THREE.TubeGeometry(centerPath, tubularSegments, radius, 8, true);
            const roadFrame = new THREE.Mesh(roadGeometry, new THREE.MeshBasicMaterial({ visible: false }));
            
            for (let i = 0; i < tubularSegments; i++) {
                const p = pathPoints[i];
                
                // Holen Sie die Tangente und den normalen Vektor
                const tangent = centerPath.getTangent(i / (tubularSegments - 1));
                const normal = new THREE.Vector3(0, 1, 0).cross(tangent).normalize();
                
                // Position f√ºr √§u√üere Curbs
                const outerPos = p.clone().add(normal.clone().multiplyScalar(radius));
                
                // Position f√ºr innere Curbs
                const innerPos = p.clone().add(normal.clone().multiplyScalar(-radius));
                
                // Erstellen Sie kleine Curb-Segmente
                for (let j = 0; j < 2; j++) { // Au√üen und Innen
                    const pos = j === 0 ? outerPos : innerPos;
                    const rotation = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), tangent);
                    
                    for (let k = 0; k < 5; k++) { // 5 Segmente pro St√ºck
                        const color = colors[k % colors.length];
                        
                        const curbGeometry = new THREE.BoxGeometry(curbSize, curbHeight, curbSize);
                        const curbMaterial = new THREE.MeshStandardMaterial({ color: color, metalness: 0.1, roughness: 0.7 });
                        const curb = new THREE.Mesh(curbGeometry, curbMaterial);
                        
                        // Rotieren
                        curb.quaternion.copy(rotation);
                        
                        // Positionieren
                        const offsetZ = curbSize * k - curbSize * 2; 
                        const offsetVector = tangent.clone().multiplyScalar(offsetZ);
                        
                        curb.position.copy(pos).add(offsetVector);
                        curb.position.y = trackY + curbHeight / 2 + 0.05; 
                        
                        curb.castShadow = true;
                        curb.receiveShadow = true;
                        curbsGroup.add(curb);
                    }
                }
            }
            scene.add(curbsGroup);
            return curbsGroup;
        }

        // <<< GE√ÑNDERT: Start-/Ziellinie (Bogen entfernt - V38)
        function createStartFinishLine(centerPath) {
            const p = centerPath.getPoint(0);
            const tangent = centerPath.getTangent(0).normalize();
            
            const roadWidth = 40;
            const lineThickness = 1;
            const lineLength = roadWidth; 
            
            const startLine = new THREE.Group();
            
            // 1. Wei√üe Ziellinie auf dem Boden
            const lineGeometry = new THREE.BoxGeometry(lineLength, 0.01, lineThickness);
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const lineMesh = new THREE.Mesh(lineGeometry, lineMaterial);
            
            // Rotation zur Tangente
            lineMesh.rotation.y = Math.atan2(tangent.x, tangent.z) - Math.PI / 2; 
            lineMesh.position.set(p.x, trackY + 0.05, p.z);
            startLine.add(lineMesh);
            
            scene.add(startLine);
        }
        
        // <<< NEU: Weihnachtsb√§ume (Kugeln hinzugef√ºgt)
        function createTrees(mapName) {
            const treeCount = gameSettings.trees === 'high' ? 100 : 30;
            const maxRange = trackSize * 0.8;
            const roadWidth = mapName === 'race_track' ? 30 : 20;

            for (let i = 0; i < treeCount; i++) {
                let treePos;
                let validPos = false;

                while (!validPos) {
                    const x = (Math.random() - 0.5) * maxRange * 2;
                    const z = (Math.random() - 0.5) * maxRange * 2;
                    treePos = new THREE.Vector3(x, 0, z);

                    if (mapName === 'snow_drift_area') {
                          if (treePos.length() > 50) {
                               validPos = true;
                          }
                    } else {
                          if (Math.abs(x) > roadWidth * 2 || Math.abs(z) > roadWidth * 2) {
                               validPos = true;
                          }
                    }
                }

                const treeGroup = new THREE.Group();
                const trunkHeight = 5 + Math.random() * 5;
                const trunkRadius = 0.5;

                const trunkGeometry = new THREE.CylinderGeometry(trunkRadius, trunkRadius, trunkHeight, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = trunkHeight / 2 + grassY;
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                treeGroup.add(trunk);

                const coneHeight = 8 + Math.random() * 4;
                const coneGeometry = new THREE.ConeGeometry(3, coneHeight, 16);
                const coneMaterial = new THREE.MeshLambertMaterial({ color: 0x004d00 }); // Dunkles Tannengr√ºn
                const cone = new THREE.Mesh(coneGeometry, coneMaterial);
                cone.position.y = trunkHeight + 2 + grassY;
                cone.castShadow = true;
                treeGroup.add(cone);

                // Christbaumkugeln
                const ornamentColors = [0xff0000, 0xffff00, 0x0000ff, 0xffffff];
                for(let k=0; k<6; k++) {
                    const ornaGeo = new THREE.SphereGeometry(0.3, 8, 8);
                    const ornaMat = new THREE.MeshBasicMaterial({ color: ornamentColors[k%4] });
                    const orna = new THREE.Mesh(ornaGeo, ornaMat);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const h = (Math.random() - 0.5) * coneHeight * 0.8; 
                    const r = (coneHeight/2 - h) * 0.3; 
                    
                    orna.position.set(Math.cos(angle)*r, h, Math.sin(angle)*r);
                    cone.add(orna);
                }

                treeGroup.position.copy(treePos);
                scene.add(treeGroup);
            }
        }

        // NEU: Spezielle Elemente f√ºr Maps
        function createBarrel(x, z) {
            const barrelGroup = new THREE.Group();
            const barrelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
            const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, metalness: 0.1, roughness: 0.8 });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.position.y = 0.5 + grassY;
            barrel.castShadow = true;
            barrel.receiveShadow = true;
            barrelGroup.add(barrel);

            // Metallringe
            const ringGeometry = new THREE.TorusGeometry(0.52, 0.05, 8, 16);
            const ringMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.1 });
            const topRing = new THREE.Mesh(ringGeometry, ringMaterial);
            topRing.position.y = 0.95 + grassY;
            topRing.rotation.x = Math.PI / 2;
            barrelGroup.add(topRing);

            const bottomRing = new THREE.Mesh(ringGeometry, ringMaterial);
            bottomRing.position.y = 0.05 + grassY;
            bottomRing.rotation.x = Math.PI / 2;
            barrelGroup.add(bottomRing);

            barrelGroup.position.set(x, 0, z);
            scene.add(barrelGroup);
        }

        function createCone(x, z) {
            const coneGeometry = new THREE.ConeGeometry(0.3, 1, 8);
            const coneMaterial = new THREE.MeshStandardMaterial({ color: 0xff4500, metalness: 0.1, roughness: 0.8 });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.position.set(x, 0.5 + grassY, z);
            cone.castShadow = true;
            cone.receiveShadow = true;
            scene.add(cone);
        }

        function createJumpRamp(x, z, rotation) {
            const rampGroup = new THREE.Group();
            const rampGeometry = new THREE.BoxGeometry(4, 0.5, 8);
            const rampMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.5, roughness: 0.5 });
            const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
            ramp.position.y = 0.25 + grassY;
            ramp.rotation.x = Math.PI / 6; // Leichte Neigung
            ramp.castShadow = true;
            ramp.receiveShadow = true;
            rampGroup.add(ramp);

            // Seitenw√§nde
            const wallGeometry = new THREE.BoxGeometry(0.2, 1, 8);
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.position.set(-1.9, 0.5 + grassY, 0);
            leftWall.castShadow = true;
            rampGroup.add(leftWall);

            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.position.set(1.9, 0.5 + grassY, 0);
            rightWall.castShadow = true;
            rampGroup.add(rightWall);

            rampGroup.position.set(x, 0, z);
            rampGroup.rotation.y = rotation;
            scene.add(rampGroup);
        }

        function createCheckpoint(x, z, rotation, isFinish) {
            const checkpointGroup = new THREE.Group();
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });

            const leftPole = new THREE.Mesh(poleGeometry, poleMaterial);
            leftPole.position.set(-2, 1.5 + grassY, 0);
            leftPole.castShadow = true;
            checkpointGroup.add(leftPole);

            const rightPole = new THREE.Mesh(poleGeometry, poleMaterial);
            rightPole.position.set(2, 1.5 + grassY, 0);
            rightPole.castShadow = true;
            checkpointGroup.add(rightPole);

            // Banner
            const bannerGeometry = new THREE.PlaneGeometry(4, 1);
            const bannerColor = isFinish ? 0x00ff00 : 0xffff00;
            const bannerMaterial = new THREE.MeshBasicMaterial({ color: bannerColor, side: THREE.DoubleSide });
            const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);
            banner.position.set(0, 2.5 + grassY, 0);
            checkpointGroup.add(banner);

            checkpointGroup.position.set(x, 0, z);
            checkpointGroup.rotation.y = rotation;
            scene.add(checkpointGroup);
        }

        function createBuilding(x, z, width, height, depth, color) {
            const buildingGroup = new THREE.Group();
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const buildingMaterial = new THREE.MeshStandardMaterial({ color: color, metalness: 0.1, roughness: 0.8 });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height / 2 + grassY;
            building.castShadow = true;
            building.receiveShadow = true;
            buildingGroup.add(building);

            // Windows
            const windowGeometry = new THREE.PlaneGeometry(2, 1.5);
            const windowMaterial = new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide });
            for (let i = 0; i < 4; i++) {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(-width/2 + 1 + i*2, height/2 - 1, depth/2 + 0.01);
                buildingGroup.add(window);
            }

            buildingGroup.position.set(x, 0, z);
            scene.add(buildingGroup);
        }
        
        // V37: Update Map-Generierung (Unver√§ndert)
        function createTrack(mapName) {
            
            // <<< GE√ÑNDERT: Schnee f√ºr ALLE Maps
            let grassMaterialColor = 0xffffff; // Immer wei√üer Schnee-Boden
            
            // 1. Gras/Boden Fl√§che erstellen
            const grassGeometry = new THREE.PlaneGeometry(trackSize * 2, trackSize * 2);
            const grassMaterial = new THREE.MeshLambertMaterial({ color: grassMaterialColor }); 
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.position.y = grassY;
            grass.receiveShadow = true;
            scene.add(grass);
            
            let roadShape, roadGeometry;
            let centerPath = null; 
            let roadMesh = null;

            // 2. Map Geometrie erstellen
            if (mapName === 'parking_lot') {
                const s = 150;
                roadShape = new THREE.Shape();
                roadShape.moveTo(-s, -s);
                roadShape.lineTo(-s, s);
                roadShape.lineTo(s, s);
                roadShape.lineTo(s, -s);
                roadShape.lineTo(-s, -s);
                roadGeometry = new THREE.ShapeGeometry(roadShape);

                const points = mapWaypoints[mapName];
                centerPath = new THREE.CatmullRomCurve3(points.map(p => new THREE.Vector3(p.x, 0, p.z)), true);

            } else if (mapName === 'race_track') {
                const points = mapWaypoints[mapName];
                const curve = new THREE.CatmullRomCurve3(points.map(p => new THREE.Vector3(p.x, 0, p.z)), true, 'centripetal');
                centerPath = curve;
                roadGeometry = new THREE.TubeGeometry(curve, 128, 20, 8, true);

            } else if (mapName === 'snow_drift_area') {
                const points = mapWaypoints[mapName];
                centerPath = new THREE.CatmullRomCurve3(points.map(p => new THREE.Vector3(p.x, 0, p.z)), false);

            } else if (mapName === 'building_city') {
                const s = 150;
                roadShape = new THREE.Shape();
                roadShape.moveTo(-s, -s);
                roadShape.lineTo(-s, s);
                roadShape.lineTo(s, s);
                roadShape.lineTo(s, -s);
                roadShape.lineTo(-s, -s);
                roadGeometry = new THREE.ShapeGeometry(roadShape);

                const points = mapWaypoints[mapName];
                centerPath = new THREE.CatmullRomCurve3(points.map(p => new THREE.Vector3(p.x, 0, p.z)), true);

            } else if (mapName === 'simple_parking_lot') {
                const s = 80;
                roadShape = new THREE.Shape();
                roadShape.moveTo(-s, -s);
                roadShape.lineTo(-s, s);
                roadShape.lineTo(s, s);
                roadShape.lineTo(s, -s);
                roadShape.lineTo(-s, -s);
                roadGeometry = new THREE.ShapeGeometry(roadShape);

                const points = mapWaypoints[mapName];
                centerPath = new THREE.CatmullRomCurve3(points.map(p => new THREE.Vector3(p.x, 0, p.z)), true);
            }

            // 3. RoadMesh hinzuf√ºgen (au√üer bei Schnee-Drift-Fl√§che, die hat kein extra Mesh)
            if (mapName !== 'snow_drift_area') {
                
                const roadTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/lava/lavatile.jpg'); 
                roadTexture.wrapS = THREE.RepeatWrapping;
                roadTexture.wrapT = THREE.RepeatWrapping;
                roadTexture.repeat.set(mapName === 'parking_lot' ? 30 : 15, mapName === 'parking_lot' ? 30 : 15);
                
                const roadMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x99aacc, // <<< GE√ÑNDERT: Bl√§ulich-Grauer Eis-Look f√ºr die Stra√üe
                    map: roadTexture, 
                    metalness: 0.3, 
                    roughness: 0.5
                });

                roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
                roadMesh.rotation.x = -Math.PI / 2;
                roadMesh.position.y = trackY;
                roadMesh.receiveShadow = true;
                roadMesh.castShadow = true; 
                scene.add(roadMesh);
                
                // Parkplatz Details (V36) + Spezial-Elemente
                if (mapName === 'parking_lot') {
                    const s = 150;
                    createParkingLines(s);

                    const boundary = s - 10;
                    for(let i = -1; i <= 1; i++) {
                        createLamppost(boundary * i, boundary);
                        createLamppost(boundary * i, -boundary);
                        createLamppost(boundary, boundary * i);
                        createLamppost(-boundary, boundary * i);
                    }

                    // Spezial-Elemente f√ºr Parkplatz
                    createBarrel(0, 30); // Hindernisse im Zentrum
                    createBarrel(30, 0);
                    createBarrel(0, -30);
                    createBarrel(-30, 0);
                    createCone(20, 20); // Slalom-Kegel
                    createCone(-20, 20);
                    createCone(20, -20);
                    createCone(-20, -20);
                    createJumpRamp(50, 50, Math.PI / 4); // Kleine Rampe
                    createCheckpoint(100, 100, Math.PI / 4, false);
                }

                // Rennstrecken-Details (V37/V38) + Spezial-Elemente
                if (mapName === 'race_track') {
                    createCurbs(centerPath);
                    createStartFinishLine(centerPath); // Nur Linie, kein Bogen mehr

                    // Spezial-Elemente f√ºr Rennstrecke
                    createBarrel(50, 100); // Hindernis nahe der Startlinie
                    createBarrel(-50, 100);
                    createCone(80, 60); // Kegel in Kurven
                    createCone(-80, 60);
                    createCone(80, -60);
                    createCone(-80, -60);
                    createJumpRamp(0, 80, 0); // Sprungrampe in der Geraden
                    createCheckpoint(100, 80, Math.PI / 2, false); // Checkpoint
                    createCheckpoint(-100, -80, -Math.PI / 2, false);
                }

                // Stadt mit Geb√§uden Details
                if (mapName === 'building_city') {
                    const s = 150;
                    createParkingLines(s);

                    // Geb√§ude um die Strecke herum
                    createBuilding(200, 0, 40, 50, 40, 0x888888); // Gro√ües Geb√§ude
                    createBuilding(-200, 0, 40, 30, 40, 0xaaaaaa);
                    createBuilding(0, 200, 40, 40, 40, 0x777777);
                    createBuilding(0, -200, 40, 35, 40, 0x999999);
                    createBuilding(150, 150, 30, 25, 30, 0xbbbbbb); // Kleineres Geb√§ude
                    createBuilding(-150, 150, 30, 20, 30, 0xcccccc);
                    createBuilding(150, -150, 30, 28, 30, 0xdddddd);
                    createBuilding(-150, -150, 30, 22, 30, 0xeeeeee);

                    // Spezial-Elemente f√ºr Stadt
                    createBarrel(50, 50); // Hindernisse
                    createBarrel(-50, -50);
                    createCone(80, 0); // Kegel f√ºr Kurven
                    createCone(-80, 0);
                    createCone(0, 80);
                    createCone(0, -80);
                    createJumpRamp(100, 0, 0); // Rampe
                    createCheckpoint(120, 120, Math.PI / 4, false);
                }

                // Einfacher Parkplatz Details
                if (mapName === 'simple_parking_lot') {
                    const s = 80;
                    createParkingLines(s);

                    // Nur grundlegende Elemente, keine Extras
                    createBarrel(0, 20);
                    createBarrel(20, 0);
                    createBarrel(0, -20);
                    createBarrel(-20, 0);
                }
            }


            return { roadMesh, centerPath }; 
        }
        
        function loadGame(mapName) {
            // Alte Objekte entfernen
            scene.children.forEach(child => {
                 if (child !== ambientLight && child !== sunLight && child !== camera && !(child instanceof THREE.Line)) {
                     scene.remove(child);
                 }
            });
            for (let i = scene.children.length - 1; i >= 0; i--) {
                const child = scene.children[i];
                if (child instanceof THREE.Line || child instanceof THREE.PointLight) { // PointLight entfernen (Laternenlicht)
                    scene.remove(child);
                }
            }

            aiCars.forEach(ai => scene.remove(ai.mesh));
            aiCars = []; 
            
            // 1. Set Map Physics Modifiers & Sky/Fog
            if (mapName === 'snow_drift_area') {
                currentMapPhysics = {
                    longitudinalGripFactor: 0.6,
                    sideGripFactor: 0.2,
                };
            } else {
                currentMapPhysics = {
                    longitudinalGripFactor: 1.0,
                    sideGripFactor: 1.0,
                };
            }
            applySettingsToGame(); 

            // 2. Boden und Strecke erstellen
            const { roadMesh, centerPath } = createTrack(mapName);
            waypoints = centerPath.points.map(p => ({ x: p.x, z: p.z })); 
            
            // 3. B√§ume/Deko √ºberall (Weihnachts-Edition)
            if (gameSettings.trees !== 'off') {
                 createTrees(mapName);
            }

            // Spezial-Elemente f√ºr Schnee-Drift-Fl√§che
            if (mapName === 'snow_drift_area') {
                createBarrel(20, 20); // Hindernisse
                createBarrel(-20, -20);
                createCone(30, 0);
                createCone(-30, 0);
                createCone(0, 30);
                createCone(0, -30);
                createJumpRamp(40, 40, Math.PI / 6); // Rampe f√ºr Spr√ºnge
                createCheckpoint(50, 50, Math.PI / 4, false);
            }
            
            // 4. Auto erstellen und positionieren
            car = createCarModel(currentCarConfig.color, false);
            const startPoint = waypoints.length > 0 ? waypoints[0] : { x: 0, z: 0 };
            
            car.position.set(startPoint.x, trackY + (0.5 * CAR_SCALE), startPoint.z + 10);
            car.rotation.y = -Math.PI / 2;
            scene.add(car);
            
            // Kamera anpassen
            camera.position.set(car.position.x + cameraBaseOffset.x, car.position.y + cameraBaseOffset.y, car.position.z + cameraBaseOffset.z);
            camera.lookAt(car.position);

            leftMarkPosition.set(car.position.x, trackY + 0.01, car.position.z);
            rightMarkPosition.set(car.position.x, trackY + 0.01, car.position.z);
            
            currentDriftPoints = 0;
            driftMultiplier = 1;
        }

        function createAICars() {
             if (waypoints.length < 2) return; 
             
             const aiCarConfigNames = ['muscle_car', 'sport_coupe'];
            
             aiCarConfigNames.forEach((configName, index) => {
                 const config = carConfigs[configName];
                 const ai = new AICar(configName, config.color, waypoints);
                
                 const offset = new THREE.Vector3(5, 0, -5 * index);
                 ai.mesh.position.add(offset);
                
                 scene.add(ai.mesh);
                 aiCars.push(ai);
             });
        }
        
        // --- STEUERUNGS-FUNKTIONEN ---

        function onKeyDown(event) {
            keys[event.key.toLowerCase()] = true;
            if (event.key === 'Escape' && isGameRunning) {
                pauseGame();
            }
        }

        function onKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }
        
        function pauseGame() {
            isGameRunning = false;
            if (currentMusicTrack) currentMusicTrack.pause();
            if (engineSound) engineSound.pause();
            if (skidSound) skidSound.pause();
            
            document.getElementById('hud').style.display = 'none';
            document.getElementById('controls-hud').style.display = 'none';
            document.getElementById('madschis-logo').style.display = 'none';
            document.getElementById('game-menu').style.display = 'flex';
        }

        // --- SPIEL-LOOP & LOGIK ---

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            if (isGameRunning) {
                updateCar(deltaTime);
                updateCamera();
                updateAI(deltaTime);
                
                checkBoundariesAndCollision();

                const speedKPH = velocity.length() * 3.6; 
                const driftAngle = getDriftAngle();
                
                updateDriftScore(driftAngle, speedKPH, deltaTime);
                updateGameSounds(speedKPH, driftAngle, deltaTime);
                updateHUD(driftAngle, speedKPH);
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        function updateAI(deltaTime) {
             aiCars.forEach(ai => ai.update(deltaTime));
        }

        // V35: Update Car mit dynamischer Grip-Anpassung (Unver√§ndert)
        function updateCar(deltaTime) {
            if (!car) return;

            const config = currentCarConfig;
            
            let driveForce = 0;
            let brakeForce = 0;
            let steerAngle = 0;

            const currentSpeed = velocity.length();

            // 1. INPUT HANDLING
            if (keys['w']) {
                driveForce = config.maxPower;
            } else if (keys['s']) {
                if (currentSpeed > 0.5) {
                    brakeForce = config.brakeForce;
                } else {
                    driveForce = -config.maxPower * 0.3; // R√ºckw√§rts
                }
            } else {
                brakeForce = currentSpeed * config.mass * 0.1;
            }

            if (keys['a']) {
                steerAngle = config.steerAngle;
            }
            if (keys['d']) {
                steerAngle = -config.steerAngle;
            }

            // 2. FORCE & GRIP SIMULATION (V35: DYNAMISCHER GRIP)
            
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(car.quaternion);
            
            const forwardVelocity = forward.clone().multiplyScalar(velocity.dot(forward));
            const sideVelocity = right.clone().multiplyScalar(velocity.dot(right));

            // Longitudinale Kraft (Antrieb und Bremsen)
            let longitudinalForce = forward.clone().multiplyScalar(driveForce);
            longitudinalForce.addScaledVector(forwardVelocity, -brakeForce * currentMapPhysics.longitudinalGripFactor); 
            
            // Seitlicher Grip (Map-spezifisch)
            let lateralGripFactor = config.sideGrip * currentMapPhysics.sideGripFactor;
            if (keys[' ']) {
                lateralGripFactor *= config.handbrakeFactor; // Handbremse reduziert den Grip weiter
            }
            
            // Seitliche Kraft (Grip)
            let sideForce = sideVelocity.clone().multiplyScalar(-lateralGripFactor * config.mass * 2.5); 
            
            let totalForce = new THREE.Vector3();
            totalForce.add(longitudinalForce);
            totalForce.add(sideForce);
            
            // 3. MOTION & ROTATION

            const accelerationVector = totalForce.divideScalar(config.mass);
            
            velocity.addScaledVector(accelerationVector, deltaTime);

            const maxSpeed = keys['s'] && currentSpeed > 0.5 ? 20 : 70;
            if (velocity.length() > maxSpeed) {
                velocity.setLength(maxSpeed);
            }
            
            car.position.addScaledVector(velocity, deltaTime);
            car.position.y = trackY + (0.5 * CAR_SCALE); 
            
            // 4. LENKUNG & AUSRICHTUNG
            
            const steerRate = steerAngle * config.steerSpeed * deltaTime;
            car.rotation.y += steerRate;

            const velocityDirection = velocity.clone().normalize();
            
            const forwardCheck = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion);
            const angleToVelocity = forwardCheck.angleTo(velocityDirection);
            
            if (currentSpeed > 0.5) {
                const correctionAxis = new THREE.Vector3(0, 1, 0); 
                const correctionDirection = forwardCheck.clone().cross(velocityDirection).dot(correctionAxis) > 0 ? 1 : -1;
                
                // Korrektur: Weniger stark auf Low-Grip-Maps
                const correctionFactor = currentMapPhysics.sideGripFactor > 0.5 ? 5 : 2; 
                if (!keys[' ']) {
                    car.rotation.y += correctionDirection * angleToVelocity * 0.5 * deltaTime * correctionFactor; 
                }
            }

            // 5. REIFEN-ANIMATION
            updateWheelRotation(deltaTime);
            
            // 6. SKID MARKS
            updateSkidMarks(getDriftAngle(), deltaTime);
        }
        
        function updateWheelRotation(deltaTime) {
            const speed = velocity.length();
            const wheelRotationSpeed = speed / (0.5 * CAR_SCALE) * deltaTime; 

            const frontLeftWheel = car.getObjectByName('frontLeftWheel');
            const frontRightWheel = car.getObjectByName('frontRightWheel');

            if (frontLeftWheel) {
                frontLeftWheel.rotation.x -= wheelRotationSpeed; 
                
                let steerRot = keys['a'] ? currentCarConfig.steerAngle : (keys['d'] ? -currentCarConfig.steerAngle : 0);
                frontLeftWheel.rotation.y = steerRot;
            }
            if (frontRightWheel) {
                frontRightWheel.rotation.x -= wheelRotationSpeed;
                
                let steerRot = keys['a'] ? currentCarConfig.steerAngle : (keys['d'] ? -currentCarConfig.steerAngle : 0);
                frontRightWheel.rotation.y = steerRot;
            }
        }

        function updateSkidMarks(driftAngle, deltaTime) {
            skidMarkTimer -= deltaTime;
            const threshold = 15; 
            
            const lowGripSkid = currentMapPhysics.sideGripFactor < 0.5;

            if (((driftAngle > threshold || keys[' ']) || lowGripSkid) && skidMarkTimer <= 0) {
                const carForward = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion);
                const carRight = new THREE.Vector3(1, 0, 0).applyQuaternion(car.quaternion);
                
                const leftOffset = carRight.clone().multiplyScalar(-1.25 * CAR_SCALE).add(carForward.clone().multiplyScalar(1.5 * CAR_SCALE));
                const rightOffset = carRight.clone().multiplyScalar(1.25 * CAR_SCALE).add(carForward.clone().multiplyScalar(1.5 * CAR_SCALE));

                const newLeftPos = car.position.clone().add(leftOffset);
                const newRightPos = car.position.clone().add(rightOffset);

                newLeftPos.y = trackY + 0.01;
                newRightPos.y = trackY + 0.01;
                
                const skidColor = lowGripSkid ? 0x666666 : 0x000000;
                const skidMarkMaterial = new THREE.LineBasicMaterial({ color: skidColor, linewidth: 3, opacity: 0.6, transparent: true });

                if (leftMarkPosition.distanceTo(newLeftPos) > 0.5) {
                     const leftPoints = [leftMarkPosition.clone(), newLeftPos.clone()];
                     const leftGeometry = new THREE.BufferGeometry().setFromPoints(leftPoints);
                     const leftMark = new THREE.Line(leftGeometry, skidMarkMaterial);
                     scene.add(leftMark);

                     const rightPoints = [rightMarkPosition.clone(), newRightPos.clone()];
                     const rightGeometry = new THREE.BufferGeometry().setFromPoints(rightPoints);
                     const rightMark = new THREE.Line(rightGeometry, skidMarkMaterial);
                     scene.add(rightMark);

                     leftMarkPosition.copy(newLeftPos);
                     rightMarkPosition.copy(newRightPos);
                } 
                
                skidMarkTimer = skidMarkDelay;
            } else { 
                 skidMarkTimer = skidMarkDelay; 
                 const carForward = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion);
                 const carRight = new THREE.Vector3(1, 0, 0).applyQuaternion(car.quaternion);
                 
                 const leftOffset = carRight.clone().multiplyScalar(-1.25 * CAR_SCALE).add(carForward.clone().multiplyScalar(1.5 * CAR_SCALE));
                 const rightOffset = carRight.clone().multiplyScalar(1.25 * CAR_SCALE).add(carForward.clone().multiplyScalar(1.5 * CAR_SCALE));
                 
                 leftMarkPosition = car.position.clone().add(leftOffset);
                 rightMarkPosition = car.position.clone().add(rightOffset);
                 leftMarkPosition.y = trackY + 0.01;
                 rightMarkPosition.y = trackY + 0.01;
            }
        }
        
        function getDriftAngle() {
            if (!car || velocity.length() < 1) return 0;

            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion).normalize();
            const velocityDirection = velocity.clone().normalize();
            
            const angleRad = forward.angleTo(velocityDirection);
            return THREE.MathUtils.radToDeg(angleRad);
        }

        function updateDriftScore(driftAngle, speedKPH, deltaTime) {
            const driftThreshold = 15; 
            const minSpeedForDrift = 10; 
            
            if (driftAngle >= driftThreshold && speedKPH >= minSpeedForDrift) {
                if (!isDrifting) {
                    isDrifting = true;
                }
                
                const driftFactorAdjustment = (currentMapPhysics.sideGripFactor < 0.5) ? 0.7 : 1.0;
                
                const angleFactor = (driftAngle - driftThreshold) / 45; 
                const speedFactor = (speedKPH - minSpeedForDrift) / 80; 
                
                const scorePerSecond = 50 * angleFactor * speedFactor * driftFactorAdjustment;
                
                const points = scorePerSecond * deltaTime;
                currentDriftPoints += points;
                
                driftMultiplier = Math.floor(currentDriftPoints / 50) + 1;
                driftMultiplier = Math.min(driftMultiplier, 10); 

            } else if (isDrifting) {
                currentScore += Math.round(currentDriftPoints * driftMultiplier);
                currentDriftPoints = 0;
                lastDriftEnd = clock.getElapsedTime();
                isDrifting = false;
                
                setTimeout(() => {
                     document.getElementById('multiplier-line').style.display = 'none';
                }, 1500); 

            } else if (!isDrifting && driftMultiplier > 1) {
                if (clock.getElapsedTime() - lastDriftEnd > multiplierResetTime) {
                     driftMultiplier = 1;
                }
            }
        }

        function updateCamera() {
            if (!car) return;

            const speedFactor = velocity.length() / 70; 
            const speedZoom = speedFactor * 0.2;
            const driftFactor = getDriftAngle() * cameraZoomDriftFactor;
            
            const currentOffset = cameraBaseOffset.clone();
            currentOffset.z -= currentOffset.z * (speedZoom + driftFactor);
            currentOffset.y += currentOffset.y * (driftFactor * 0.5);

            const rotatedOffset = currentOffset.applyQuaternion(car.quaternion);

            const targetPosition = car.position.clone().add(rotatedOffset);
            
            camera.position.lerp(targetPosition, 0.15); 
            
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion);
            const lookAtOffset = forward.multiplyScalar(10 + velocity.length() * 0.5);
            const lookAtTarget = car.position.clone().add(lookAtOffset);
            
            camera.lookAt(lookAtTarget);
        }
        
        function checkBoundariesAndCollision() {
            let collision = false;
            
            if (Math.abs(car.position.x) > trackSize || Math.abs(car.position.z) > trackSize) {
                const boundary = trackSize;
                car.position.x = THREE.MathUtils.clamp(car.position.x, -boundary, boundary);
                car.position.z = THREE.MathUtils.clamp(car.position.z, -boundary, boundary);
                
                velocity.multiplyScalar(-0.5); 
                collision = true;
            }
            
            // TODO: Kurvenbegrenzungen (Curbs) als Kollisions-Objekte f√ºr Rennstrecke hinzuf√ºgen

            aiCars.forEach(ai => {
                if (car.position.distanceTo(ai.mesh.position) < 3.5 * CAR_SCALE) {
                    const collisionVector = car.position.clone().sub(ai.mesh.position).normalize();
                    
                    car.position.addScaledVector(collisionVector, 0.5);
                    velocity.addScaledVector(collisionVector, 10);
                    
                    ai.mesh.position.addScaledVector(collisionVector.negate(), 0.5);
                    ai.velocity.addScaledVector(collisionVector.negate(), 10);
                    
                    collision = true;
                }
            });
            
            if (collision && collisionSound && collisionSound.paused) {
                 collisionSound.currentTime = 0;
                 collisionSound.play();
            }
        }

        function updateHUD(driftAngle, speedKPH) {
            document.getElementById('speed-value').textContent = Math.round(speedKPH);
            document.getElementById('score-value').textContent = currentScore;
            
            if (isDrifting) {
                const scoreText = '  (+' + Math.round(currentDriftPoints * driftMultiplier) + ')';
                document.getElementById('drift-angle-value').textContent = Math.round(driftAngle) + '¬∞' + scoreText;
            } else {
                document.getElementById('drift-angle-value').textContent = Math.round(driftAngle) + '¬∞';
            }
            
            if (driftMultiplier > 1) {
                document.getElementById('multiplier-line').style.display = 'block';
                document.getElementById('multiplier-value').textContent = driftMultiplier;
            } else if (!isDrifting) {
                document.getElementById('multiplier-line').style.display = 'none';
            }
        }
        
    </script>
</body>
</html>
